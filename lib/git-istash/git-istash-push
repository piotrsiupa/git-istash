#!/usr/bin/env sh

set -e

. "$(dirname "$0")/git-istash-commons"

print_help() {
	printf 'git istash push - Improved version of "git stash push" that can handle orphan\n    branches.\n'
	printf '\n'
	printf 'This is only a rudimentary help text. Prefer "git help istash" if available.\n'
	printf '\n'
	printf 'Usage: git istash push\n'
	printf '   or: git istash push -h\n'
	printf '\n'
	printf 'Options:\n'
	printf '    -a, --all\t\t- Stash and clean also untracked and ignored files.\n'
	printf '    -h\t\t\t- Show this help text and exit.\n'
	printf '    -k, --keep-index\t- Left intact all changes already added to the index.\n'
	printf '\t--no-keep-index\t- Cancel "--keep-index".\n'
	printf '    -m, --message=MSG\t- Set stash description.\n'
	printf '    -u, --include-untracked - Stash and clean also untracked files.\n'
	printf '\t--no-include-untracked - Do not touch untracked files even with "--all".\n'
}

prepare_octal_conversion() {
	if command -v od 1>/dev/null 2>&1
	then
		convert_to_octal() {
			#shellcheck disable=SC1003
			od -bvAn | tr ' ' '\\' | tr -d '\n'
		}
	else
		convert_to_octal() {
			hexdump -ve'"\\" /1 "%02o"'
		}
	fi
}

initialize() {
	if [ "$include_ignored" = y ] || [ "$include_untracked" = y ]
	then
		has_3_commits=y
	else
		has_3_commits=n
	fi
	
	if [ "$has_3_commits" = y ]
	then
		prepare_octal_conversion
	fi
}

commit_changes() {
	default_message="$(git rev-list --no-commit-header --format='%h %s' --max-count=1 HEAD)"
	if [ "$curr_branch_type" != 'detached' ]
	then
		branch_name_for_msg="$(git branch --show-current)"
	else
		branch_name_for_msg='(no branch)'
	fi
	git commit --message="index on $branch_name_for_msg: $default_message" --allow-empty
	git add --update
	if [ -n "$message" ]
	then
		git commit --message="On $branch_name_for_msg: $message" --allow-empty
	else
		git commit --message="WIP on $branch_name_for_msg: $default_message" --allow-empty
	fi
	if [ "$has_3_commits" = y ]
	then
		if [ "$include_untracked" = n ]
		then
			git ls-files --exclude-standard --others --ignored -z | xargs -0 -- git add --force
		elif [ "$include_ignored" = n ]
		then
			git add --all
		else
			git add --all --force
		fi
		git commit --message="untracked files on $branch_name_for_msg: $default_message" --allow-empty
	fi
}

sanitize_ls_tree() {
	convert_to_octal \
	| sed -E 's/\\0{1,3}(\\|$)/\n\1/g' \
	| sed -E 's/(\\0{0,2}[0-7]|\\0?[^4][0-7]|\\0?4[1-7]|\\[1-3][0-7]{2})+\\0?40(\\0{0,2}[0-7]|\\0?[^4][0-7]|\\0?4[1-7]|\\[1-3][0-7]{2})+\\0?40(\\0{0,2}[0-7]|\\0?[^1][0-7]|\\0?1[02-7]|\\[1-3][0-7]{2})+\\0?11/&\n/' \
	| while read -r data && read -r path
	do
		printf "$data%s\n" "$path"
	done \
	| sed -E 's/\\0?57\\/\/\\/g'
}

remove_tracked_files_from_HEAD() ( # [path]
	if [ $# -lt 1 ]
	then
		set -- './'
	fi
	previous_files="$(git ls-tree -z HEAD~ "$1" | sanitize_ls_tree)"
	git ls-tree -z HEAD "$1" | sanitize_ls_tree \
	| while read -r line
	do
		if printf '%s' "$previous_files" | grep -qxF "$line"
		then
			continue
		fi
		if [ "$(printf '%s\n' "$line" | awk '{print $2}')" = 'blob' ]
		then
			printf '%s\\000' "$line"
		else
			#shellcheck disable=SC2059
			subtree_sha="$(remove_tracked_files_from_HEAD "$(printf "$line" | sed -E '1 s/^.*\t//')/")"
			printf '%s\\000' "$line" | sed -E 's;^(\w+\s+\w+\s+)\w+(\s);\1'"$subtree_sha"'\2;'
		fi | sed -E 's;^(.*\t)(.*/)?([^/]+)$;\1\3;'
	done | xargs -r0 -- printf \
	| git mktree -z
)

tangle_stash() {
	if [ "$has_3_commits" = n ]
	then
		stash_sha="$(git show -s --format=%B HEAD | git commit-tree 'HEAD^{tree}' -p HEAD~2 -p HEAD~1)"
	else
		untracked_tree_sha="$(remove_tracked_files_from_HEAD)"
		untracked_sha="$(git show -s --format=%B HEAD | git commit-tree "$untracked_tree_sha")"
		stash_sha="$(git show -s --format=%B HEAD~1 | git commit-tree 'HEAD~1^{tree}' -p HEAD~3 -p HEAD~2 -p "$untracked_sha")"
	fi
	git stash store "$stash_sha" --message="$(git show -s --format=%B "$stash_sha")"
}

restore_working_tree() {
	if [ "$has_3_commits" = n ]
	then
		if [ "$keep_index" = n ]
		then
			git reset --hard HEAD~2
		else
			git reset --hard HEAD~1
			git reset --soft HEAD~1
		fi
	else
		if [ "$keep_index" = n ]
		then
			git reset --hard HEAD~3
		else
			git reset --hard HEAD~2
			git reset --soft HEAD~1
		fi
	fi
}

create_stash() {
	commit_changes
	tangle_stash
	restore_working_tree
}

create_temporary_branch() {
	git commit --message="Base commit for stash entry on an orphan branch \"$current_branch\"" --allow-empty --no-verify --only --
}

remove_temporary_branch() {
	git switch --detach HEAD
	git branch --delete --force "$current_branch"
	git switch --orphan "$current_branch"
}

do_push() {
	initialize
	find_current_branch
	if [ "$curr_branch_type" = 'orphan' ]
	then
		create_temporary_branch
		create_stash
		remove_temporary_branch
	else
		create_stash
	fi
}

getopt_result="$(getopt -o'ahkm:u' --long='all,keep-index,no-keep-index,message:,include-untracked,no-include-untracked' -n"$(basename "$0")" -ssh -- "$@")"
eval set -- "$getopt_result"
include_ignored=n
keep_index=n
message=''
include_untracked=d
while true
do
	case "$1" in
	-a|--all)
		include_ignored=y
		if [ "$include_untracked" = d ]
		then
			include_untracked=y
		fi
		;;
	-h)
		print_help
		exit 0
		;;
	-k|--keep-index)
		keep_index=y
		;;
	--no-keep-index)
		keep_index=n
		;;
	-m|--message)
		shift
		message="$1"
		;;
	-u|--include-untracked)
		include_untracked=y
		;;
	--no-include-untracked)
		include_untracked=n
		;;
	--)
		shift
		break
		;;
	esac
	shift
done
if [ "$include_untracked" = d ]
then
	include_untracked=n
fi

cd "$(git rev-parse --show-toplevel)"
do_push
