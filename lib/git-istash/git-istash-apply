#!/usr/bin/env sh

set -e

. "$(dirname "$0")/git-istash-commons"

print_help() {
	printf 'git istash apply - Improved version of "git stash apply" that can handle\n    conflicts without loosing information about the files in index.\n'
	printf '\n'
	printf 'This is only a rudimentary help text. Prefer "git help istash" if available.\n'
	printf '\n'
	printf 'Usage: git istash apply [<stash>]\n'
	printf '   or: git istash apply (-c | --continue | --abort)\n'
	printf '   or: git istash apply -h\n'
	printf '\n'
	printf 'Options:\n'
	printf '\t--abort\t\t- Abort the previous operation and return the repository\n\t\t\t  to the state before it started.\n'
	printf '    -c, --continue\t- Resume the previous operation.\n\t\t\t  (Conflicts need to be resolved before that.)\n'
	printf '    -h\t\t\t- Show this help text and exit.\n'
}

get_sub_command_name() { #
	if [ "$is_pop" = n ]
	then
		printf 'apply'
	else
		printf 'pop'
	fi
}

save_data() {
	target_data="$(if [ "$curr_branch_type" = 'orphan' ] ; then printf '~' ; fi ; printf '%s' "$current_branch")"
	printf '%s\n' "$target_data" >"$target_data_file"
	
	printf '%s\n' "$working_dir_changes_sha" >"$working_dir_sha_file"
}
load_data() {
	if [ "$(wc -l <"$target_data_file")" -ne 1 ]
	then
		printf 'fatal: "%s" is should contain exactly 1 line.\n' "$target_data_file" 1>&2
		return 1
	fi
	current_branch="$(cat "$target_data_file")"
	if printf '%s' "$current_branch" | grep -qE '^~'
	then
		current_branch="$(printf '%s' "$current_branch" | cut -c2-)"
		curr_branch_type='orphan'
	else
		curr_branch_type='normal'
	fi
	if ! git rev-parse --quiet --verify "$current_branch^{commit}" 1>/dev/null
	then
		printf 'fatal: "%s" says "%s" but there is no such commit.\n' "$target_data_file" "$current_branch" 1>&2
		return 1
	fi
	if [ "$curr_branch_type" != 'orphan' ] && [ "$(git rev-parse "$current_branch")" = "$current_branch" ]
	then
		curr_branch_type='detached'
	fi
	
	working_dir_changes_sha="$(cat "$working_dir_sha_file")"
}
delete_data() {
	rm -f "$target_data_file" "$working_dir_sha_file"
}

check_args_for_apply() { # max_free_args args...
	check_args 'istash apply' "$@"
}

put_files_into_working_copy() { # untracked_changes_sha non_staged_changes_sha staged_changes_sha
	git restore --source="$3" -- . || true
	git add -- .
	git restore --source="$1" -- . || true
	git --no-literal-pathspecs ls-tree -r --name-only "$2" -z :/ \
	| xargs -r0 -- git --literal-pathspecs add --intent-to-add --
}

end_with_rebase_problem() {
	printf '\n' 1>&2
	if is_color_allowed 2
	then
		printf '\033[33m'
	fi
	sub_command_name="$(get_sub_command_name)"
	printf 'hint: Disregard all hints above about using "git rebase".\n' 1>&2
	printf 'hint: Use "git istash %s --continue" after fixing conflicts.\n' "$sub_command_name" 1>&2
	printf 'hint: To abort and get back to the state before "git istash %s", run "git istash %s --abort".\n' "$sub_command_name" "$sub_command_name" 1>&2
	if is_color_allowed 2
	then
		printf '\033[39m'
	fi
	return 2
}
end_with_success() {
	if { [ "$curr_branch_type" != 'orphan' ] && [ "$(git rev-parse HEAD~6)" != "$(git rev-parse "$current_branch")" ] ; } \
		|| { [ "$curr_branch_type" = 'orphan' ] && [ "$(git rev-list --no-walk --count HEAD~6^@)" != '0' ] ; }
	then
		printf 'fatal: HEAD is not in correct position after rebasing.\n' 1>&2
		return 1
	fi
	untracked_changes_sha="$(git rev-parse HEAD~0)"
	non_staged_changes_sha="$(git rev-parse HEAD~2)"
	staged_changes_sha="$(git rev-parse HEAD~4)"
	case "$curr_branch_type" in
		orphan)
			if [ -n "$(git ls-tree -r --name-only HEAD~6)" ]
			then
				printf 'fatal: The empty commit created for the command is not empty.\n' 1>&2
				return 1
			fi
			git branch --delete --force "$current_branch"
			git switch --orphan "$current_branch"
			;;
		normal)
			git switch "$current_branch"
			;;
		detached)
			git switch -d HEAD~6
			;;
	esac
	put_files_into_working_copy "$untracked_changes_sha" "$non_staged_changes_sha" "$staged_changes_sha"
	delete_data
	printf '\nSuccessfully applied the stash\n'
}

check_data_files() { # resume
	if [ "$is_pop" = y ] ; then return 0 ; fi
	case "$(find_data_files)" in
		pop)
			printf '\n' 1>&2
			if is_color_allowed 2
			then
				printf '\033[33m'
			fi
			printf 'fatal: "git istash pop" is already in progress?\n' 1>&2
			printf 'hint: Finish that operation before starting "git istash apply".\n' 1>&2
			if is_color_allowed 2
			then
				printf '\033[39m'
			fi
			return 1
			;;
		apply)
			if [ "$1" = y ] ; then return 0 ; fi
			if is_color_allowed 2
			then
				printf '\033[33m'
			fi
			printf 'fatal: "git istash apply" is already in progress?\n' 1>&2
			printf 'hint: Use "git istash apply --continue" or "git istash apply --abort".\n' 1>&2
			if is_color_allowed 2
			then
				printf '\033[39m'
			fi
			return 1
			;;
		error)
			printf '\n' 1>&2
			if is_color_allowed 2
			then
				printf '\033[31m'
			fi
			printf 'fatal: "git istash pop" seems to be in progress but "%s" is missing!\n' "$target_data_file" 1>&2
			if is_color_allowed 2
			then
				printf '\033[33m'
			fi
			printf 'hint: Fix the problem and finish that operation before starting "git istash apply"\n' 1>&2
			printf 'hint: or remove the file "%s" to manually cancel it.\n' "$(make_stash_data_file_path)" 1>&2
			if is_color_allowed 2
			then
				printf '\033[39m'
			fi
			return 1
			;;
		nothing)
			if [ "$1" = n ] ; then return 0 ; fi
			printf 'fatal: No istash apply in progress?\n' 1>&2
			return 1
			;;
	esac
}

untangle_git_stash() {
	stash_commit="$(get_stash_commit "$stash")"
	git switch --detach "$stash_commit^2"
	git reset --hard "$(git commit-tree -p 'HEAD' -m "$(git log --format=%B --max-count=1 "$stash_commit")" "$stash_commit^{tree}")"
	if git rev-parse "$stash_commit^3" 1>/dev/null 2>&1
	then
		git ls-tree -r --name-only "$stash_commit^3" -z \
		| xargs -r0 -- git --literal-pathspecs restore --source="$stash_commit^3" --
		git add .
		git commit --no-edit --no-verify --allow-empty --message="$(git log --format=%B --max-count=1 "$stash_commit^3")"
	else
		git commit --no-edit --no-verify --allow-empty --message 'There are no untracked files'
	fi
}

commit_working_directory() {
	# initialization
	git switch --detach HEAD
	
	# staged
	git commit --message='staged' --allow-empty 1>/dev/null
	
	# unstaged
	git --no-literal-pathspecs add --update :/ 1>&2 2>/dev/null || true
	git commit --message='unstaged' --allow-empty 1>/dev/null
	
	# untracked
	git --no-literal-pathspecs add --all --intent-to-add :/ 2>/dev/null || true
	git --no-literal-pathspecs add --update :/ 1>&2 2>/dev/null || true
	git commit --message='untracked' --allow-empty 1>/dev/null
	
	# save sha
	working_dir_changes_sha="$(git rev-parse 'HEAD')"
}

start_rebase() {
	todo_list_editor="sed -i -E \
			-e '1 i pick $working_dir_changes_sha~2 Staged working directory' \
			-e '2 i pick $working_dir_changes_sha~1 Unstaged working directory' \
			-e '3 i pick $working_dir_changes_sha~0 Untracked working directory'"
	GIT_EDITOR="$todo_list_editor" git rebase --onto "$current_branch" "HEAD~3" "HEAD" --empty=keep --keep-empty --reapply-cherry-picks --interactive
}

do_start() { # args...
	check_args_for_apply 1 "$@"
	check_data_files n
	check_other_git_commands_state
	find_stash "$@"
	find_current_branch
	if [ "$curr_branch_type" = 'orphan' ]
	then
		git commit --only --allow-empty --message 'Temporary commit by "git-stash"'
	fi
	commit_working_directory
	save_data
	untangle_git_stash
	if start_rebase
	then
		end_with_success
	elif are_there_conflicts
	then
		end_with_rebase_problem
	else
		do_abort
		return 1
	fi
}

do_continue() { # args...
	check_args_for_apply 0 "$@"
	check_data_files y
	load_data
	
	git commit --allow-empty --no-edit 2>/dev/null || true
	if git -c 'core.editor=true' rebase --continue
	then
		end_with_success
	elif are_there_conflicts
	then
		end_with_rebase_problem
	else
		git reset --soft HEAD~
		return 1
	fi
}

do_abort() { # args...
	check_args_for_apply 0 "$@"
	check_data_files y
	load_data
	
	git rebase --abort || true  # Errors are ignored because if rebase is not in progress, we still want to try to restore HEAD.
	succeeded_switch=n
	case "$curr_branch_type" in
		orphan)
			git branch --delete --force "$current_branch"
			if git switch --orphan "$current_branch"
			then
				succeeded_switch=y
			fi
			;;
		normal)
			if git switch --quiet "$current_branch"
			then
				succeeded_switch=y
			fi
			;;
		detached)
			if git switch --detach --quiet "$current_branch"
			then
				succeeded_switch=y
			fi
			;;
	esac
	if [ "$succeeded_switch" = y ]
	then
		put_files_into_working_copy "$(git rev-parse "$working_dir_changes_sha~0")" "$(git rev-parse "$working_dir_changes_sha~1")" "$(git rev-parse "$working_dir_changes_sha~2")"
		delete_data
		printf 'Aborted "git istash"\n' 1>&2
	else
		printf '\n' 1>&2
		printf 'fatal: Failed to restore HEAD.\n' 1>&2
		if is_color_allowed 2
		then
			printf '\033[33m'
		fi
		printf 'hint: Fix problems and rerun "git istash %s --abort"\n' "$(get_sub_command_name)" 1>&2
		if [ "$is_pop" = n ]
		then
			printf 'hint: or delete the files "%s" and "%s" to cancel manually.\n' "$target_data_file" "$working_dir_sha_file" 1>&2
		else
			printf 'hint: or delete the files "%s", "%s" and "%s" to cancel manually.\n' "$(make_stash_data_file_path)" "$target_data_file" "$working_dir_sha_file" 1>&2
		fi
		if is_color_allowed 2
		then
			printf '\033[39m'
		fi
		return 1
	fi
}

do_apply() { # args...
	if [ "$continue_set" = y ]
	then
		do_continue "$@"
	elif [ "$abort_set" = y ]
	then
		do_abort "$@"
	else
		do_start "$@"
	fi
}

getopt_short_options='ch'
getopt_long_options='abort,_called-from-pop,_called-from-pop_,continue'
getopt_result="$(getopt -o"$getopt_short_options" --long="$getopt_long_options" -n"$(basename "$0")" -ssh -- "$@")"
eval set -- "$getopt_result"
abort_set=n
is_pop=n
continue_set=n
while true
do
	case "$1" in
	--abort)
		abort_set=y
		;;
	--_called-from-pop*)
		is_pop=y
		;;
	-c|--continue)
		continue_set=y
		;;
	-h)
		print_help
		exit 0
		;;
	--)
		shift
		break
		;;
	esac
	shift
done
if [ $continue_set = y ] && [ $abort_set = y ]
then
	printf 'error: Unclear whether to continue aborting or to abort continuing.\n' 1>&2
	exit 1
fi

cd "$(git rev-parse --show-toplevel)"
target_data_file="$(make_target_data_file_path)"
working_dir_sha_file="$(make_working_dir_sha_file_path)"
do_apply "$@"
