is_color_allowed() { # stream_num
	case "$(git config --get color.ui)" in
		always|true|1) return 0 ;;
		never|false|0) return 1 ;;
		*)             test -t "$1" ;;
	esac
}

make_data_file_path() { # name
	git rev-parse --git-dir | tr -d '\n'
	printf '/istash %s' "$1" | tr ' [:lower:]' '_[:upper:]'
}
make_target_data_file_path() {
	make_data_file_path 'target'
}
make_stash_data_file_path() {
	make_data_file_path 'stash'
}

find_data_files() {
	if [ -f "$(make_target_data_file_path)" ]
	then
		if [ -f "$(make_stash_data_file_path)" ]
		then
			printf 'pop'
		else
			printf 'apply'
		fi
	else
		if [ -f "$(make_stash_data_file_path)" ]
		then
			printf 'error'
		else
			printf 'nothing'
		fi
	fi
}

check_args() { # max_free_args args...
	_script_name="$1"
	_max_free_args="$2"
	shift 2
	if [ $# -gt "$_max_free_args" ]
	then
		printf 'error: Too many arguments.\n' 1>&2
		printf 'error: Type "git %s --help" for more information.\n' "$_script_name" 1>&2
		exit 1
	fi
}

check_repository_state() {
	if [ -n "$(git status --porcelain)" ]
	then
		# There are still are some limitations.
		printf 'error: There are uncommitted changes in the working directory.\n' 1>&2
		printf 'error: Please commit or stash them.\n' 1>&2
		exit 1
	fi
}

check_other_git_commands_state() {
	git_dir="$(git rev-parse --git-dir)"
	if [ -e "$git_dir/rebase-apply" ] || [ -e "$git_dir/rebase-merge" ]
	then
		printf 'error: There is currently a rebase in progress.\n' 1>&2
		exit 1
	fi
	if [ -e "$git_dir/MERGE_HEAD" ]
	then
		printf 'error: There is currently a merge in progress.\n' 1>&2
		exit 1
	fi
}

get_stash_commit() { # stash
	if [ "$1" -eq "$1" ] 2>/dev/null
	then
		printf '%s' "stash@{$1}"
	else
		printf '%s' "$1"
	fi
}

find_stash() { # [arg]
	if [ $# -eq 0 ] || [ "$1" = 'stash' ]
	then
		stash=0
	elif [ "$1" -eq "$1" ] 2>/dev/null
	then
		if [ "$1" -ge 0 ]
		then
			stash=$1
		else
			stash=$(($(git rev-list --walk-reflogs --count --ignore-missing refs/stash) + $1))
		fi
	elif printf '%s' "$1" | grep -xq 'stash\^{/.*}'
	then
		stash_text="$(printf '%s' "$1" | sed 's/^stash\^{\/\(.*\)}$/\1/')"
		stash_hash="$(git rev-list --walk-reflogs --grep-reflog="$stash_text" --ignore-missing refs/stash | head -n1)"
		stash="$(($(git rev-list --walk-reflogs refs/stash | grep -Fxn "$stash_hash" | cut -d: -f1) - 1))"
	elif printf '%s' "$1" | grep -xq 'stash@{[0-9]\+}'
	then
		stash="$(printf '%s' "$1" | sed 's/^stash@{\(.*\)}$/\1/')"
	else
		stash="$1"
	fi
	check_stash "$stash"
}

check_stash() { # stash
	stash_commit="$(get_stash_commit "$1")"
	if ! git rev-parse --quiet --verify "$stash_commit^{commit}" 1>/dev/null
	then
		printf 'fatal: There is no commit "%s".\n' "$stash_commit" 1>&2
		exit 1
	fi
	parents_num="$(git rev-list --no-walk --count "$stash_commit^@")"
	if [ "$parents_num" -lt 2 ] || [ "$parents_num" -gt 3 ]
	then
		printf 'fatal: "%s" should have 2 or 3 parents to be a stash.\n' "$stash_commit" 1>&2
		exit 1
	fi
	if [ "$parents_num" -eq 3 ] && [ "$(git rev-list --no-walk --count "$stash_commit^3^@")" -ne 0 ]
	then
		printf 'fatal: "%s^3" should have no parents to be a part of a stash.\n' "$stash_commit" 1>&2
		exit 1
	fi
	if [ "$(git rev-list --no-walk --count "$stash_commit^2^@")" -ne 1 ]
	then
		printf 'fatal: The commit "%s^2" should have one parent to be a part of a stash.\n' "$stash_commit" 1>&2
		exit 1
	fi
	if [ "$(git rev-parse "$stash_commit^1")" != "$(git rev-parse "$stash_commit^2^")" ]
	then
		printf 'fatal: The commit "%s^1" should be the parent of "%s^2" to be a part of a stash.\n' "$stash_commit" "$stash_commit" 1>&2
		exit 1
	fi
	correct_commit_msgs=0
	if [ "$parents_num" -eq 3 ] && git rev-list --format='%B' --max-count=1 "$stash_commit^3" | head -n 2 | tail -n 1 | grep -q '^untracked files on .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if git rev-list --format='%B' --max-count=1 "$stash_commit^2" | head -n 2 | tail -n 1 | grep -q '^index on .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if git rev-list --format='%B' --max-count=1 "$stash_commit" | head -n 2 | tail -n 1 | grep -q '^\(WIP on\|On\) .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if [ $correct_commit_msgs -ne "$parents_num" ]
	then
		if [ $correct_commit_msgs -eq 0 ]
		then
			printf 'error: "%s"'\''s commits don'\''t have correct messages for stash.\n' "$stash_commit" 1>&2
		else
			printf 'error: some of "%s"'\'' commits don'\''t have correct messages for stash.\n' "$stash_commit" 1>&2
		fi
		printf 'error: It may not be a stash entry or it may be damaged.\n'
		exit 1
	fi
}

find_current_branch() {
	if git rev-parse HEAD >/dev/null 2>&1
	then
		target="$(git rev-parse --abbrev-ref HEAD)"
		target_type='normal'
		if [ "$target" = 'HEAD' ]
		then
			target="$(git rev-parse HEAD)"
			target_type='detached'
		fi
	else
		target="$(git branch --show-current)"
		#shellcheck disable=SC2034
		target_type='orphan'
	fi
}

are_there_conflicts() {
	git status --porcelain | grep -q '^.U\|^U.'
}
