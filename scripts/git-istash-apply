#!/usr/bin/env sh

set -e

. "$(dirname "$0")/.git-istash/git-istash-commons"

print_help() {
	printf 'git-istash-apply - Improved version of "git stash apply" that can handle\n    conflicts.\n'
	printf '\n'
	printf 'usage: git istash-apply [<stash>]\n'
	printf '   or: git istash-apply (-c | --continue | --abort)\n'
}

save_data() {
	target_data="$(if [ "$orphan" = y ] ; then printf '~' ; fi ; printf '%s' "$target")"
	printf '%s\n' "$target_data" >"$target_data_file"
}
does_data_exits() {
	[ -f "$target_data_file" ]
}
load_data() {
	if ! does_data_exits
	then
		printf 'fatal: No istash in progress?\n' 1>&2
		exit 1
	elif [ "$(wc -l <"$target_data_file")" -ne 1 ]
	then
		printf 'fatal: "%s" is should contain exactly 1 line.\n' "$target_data_file" 1>&2
		exit 1
	else
		target="$(cat "$target_data_file")"
		if printf '%s' "$target" | grep -q '^~'
		then
			orphan=y
			target="$(printf '%s' "$target" | cut -c2-)"
		else
			orphan=n
		fi
		if ! git rev-parse --quiet --verify "$target^{commit}" 1>/dev/null
		then
			printf 'fatal: "%s" says "%s" but there is no such commit.\n' "$target_data_file" "$target" 1>&2
			exit 1
		fi
		if [ "$orphan" = n ] && [ "$(git rev-parse "$target")" = "$target" ]
		then
			detached=y
		else
			detached=n
		fi
	fi
}
delete_data() {
	rm -f "$target_data_file"
}

check_args_for_apply() { # max_free_args args...
	check_args 'istash-apply' "$@"
}

end_with_rebase_problem() {
	printf '\n' 1>&2
	if is_color_allowed 2
	then
		printf '\e[33m'
	fi
	printf 'hint: Disregard all hints above about using "git rebase".\n' 1>&2
	printf 'hint: Use "git istash-apply --continue" after fixing conflicts.\n' 1>&2
	printf 'hint: To abort and get back to the state before "git istash-apply", run "git istash-apply --abort".\n' 1>&2
	if is_color_allowed 2
	then
		printf '\e[39m'
	fi
	exit 1
}
end_with_success() {
	other_changes_hash="$(git rev-parse HEAD)"
	staged_changes_hash="$(git rev-parse HEAD~)"
	if [ "$orphan" = n ] && [ "$(git rev-parse HEAD~2)" != "$(git rev-parse "$target")" ]
	then
		printf 'fatal: HEAD is not in correct position after rebasing.\n' 1>&2
		exit 1
	fi
	if [ "$orphan" = 'y' ]
	then
		if [ "$(git rev-list --no-walk --count HEAD~2^@)" -ne 0 ]
		then
			printf 'fatal: Target branch is not an orphan anymore.\n' 1>&2
			exit 1
		fi
		if [ -n "$(git ls-tree -r --name-only HEAD~2)" ]
		then
			printf 'fatal: The empty commit created for the command is not empty.\n' 1>&2
			exit 1
		fi
		git branch --delete --force "$target"
		git switch --orphan "$target"
	elif [ "$detached" = n ]
	then
		git switch "$target"
	else
		git switch -d HEAD~2
	fi
	git restore --source="$staged_changes_hash" -- . || true
	git add -- .
	git restore --source="$other_changes_hash" -- . || true
	delete_data
	printf '\nSuccessfully applied the stash\n'
}

check_repository_state() {
	if [ -n "$(git status --porcelain)" ]
	then
		# There are still are some limitations.
		printf 'error: There are uncommitted changes in the working directory.\n' 1>&2
		printf 'error: Please commit or stash them.\n' 1>&2
		exit 1
	fi
}

untangle_git_stash() {
	stash_commit="$(get_stash_commit "$stash")"
	git switch --detach "$stash_commit^2"
	git merge --ff-only --squash "$stash_commit"
	if git rev-parse "$stash_commit^3" 1>/dev/null 2>&1
	then
		git ls-tree -r --name-only "$stash_commit^3" -z \
		| xargs -r0 -- git restore --source="$stash_commit^3" --
		git add .
	fi
	git commit --no-edit --no-verify --allow-empty
}

do_start() { # args...
	check_args_for_apply 1 "$@"
	if does_data_exits
	then
		printf '\n' 1>&2
		if is_color_allowed 2
		then
			printf '\e[33m'
		fi
		printf 'fatal: Istash already in progress?\n' 1>&2
		printf 'hint: Use "git istash --continue" or "git istash --abort".\n' 1>&2
		if is_color_allowed 2
		then
			printf '\e[39m'
		fi
		exit 1
	fi
	check_repository_state
	find_stash "$@"
	find_current_branch
	save_data
	
	if [ "$orphan" = y ]
	then
		git commit --allow-empty --message 'Temporary commit by "git-stash"'
	fi
	untangle_git_stash
	if git rebase --onto "$target" "HEAD~2" "HEAD" --empty=keep --keep-empty
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_continue() { # args...
	check_args_for_apply 0 "$@"
	load_data
	
	if git -c 'core.editor=true' rebase --continue
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_abort() { # args...
	check_args_for_apply 0 "$@"
	load_data
	
	git rebase --abort || true  # Errors are ignored because if rebase is not in progress, we still want to try to restore HEAD.
	succeeded_switch=n
	if [ "$orphan" = y ]
	then
		git branch --delete --force "$target"
		if git switch --orphan "$target"
		then
			succeeded_switch=y
		fi
	elif [ "$detached" = n ]
	then
		if git switch --quiet "$target"
		then
			succeeded_switch=y
		fi
	else
		if git switch --detach --quiet "$target"
		then
			succeeded_switch=y
		fi
	fi
	if [ "$succeeded_switch" = y ]
	then
		delete_data
		printf 'Aborted "git istash"\n' 1>&2
	else
		printf '\n' 1>&2
		printf 'fatal: Failed to restore HEAD.\n' 1>&2
		if is_color_allowed 2
		then
			printf '\e[33m'
		fi
		printf 'hint: Fix problems and rerun "git istash-apply --abort"\n' 1>&2
		printf 'hint: or delete the file "%s" to cancel manually.\n' "$target_data_file" 1>&2
		if is_color_allowed 2
		then
			printf '\e[39m'
		fi
		exit 1
	fi
}

do_unstash() { # args...
	if [ "$continue_set" = y ]
	then
		do_continue "$@"
	elif [ "$abort_set" = y ]
	then
		do_abort "$@"
	else
		do_start "$@"
	fi
}

getopt_result="$(getopt -o'hc' --long='help,continue,abort' -n"$(basename "$0")" -- "$@")"
eval set -- "$getopt_result"
continue_set=n
abort_set=n
while true
do
	case "$1" in
	-h|--help)
		print_help
		exit 0
		;;
	-c|--continue)
		continue_set=y
		;;
	--abort)
		abort_set=y
		;;
	--)
		shift
		break
		;;
	esac
	shift
done
if [ $continue_set = y ] && [ $abort_set = y ]
then
	printf 'error: Unclear whether to continue aborting or to abort continuing.\n' 1>&2
	exit 1
fi

cd "$(git rev-parse --show-toplevel)"
target_data_file="$(make_data_file_path 'target')"
do_unstash "$@"
