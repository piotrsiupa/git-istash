#!/usr/bin/env sh

set -e

. "$(dirname "$0")/.git-istash/git-istash-commons"

print_help() {
	printf 'git-istash-apply - Improved version of "git stash apply" that can handle\n    conflicts.\n'
	printf '\n'
	printf 'usage: git istash-apply [<stash>]\n'
	printf '   or: git istash-apply (-c | --continue | --abort)\n'
}

get_sub_command_name() { #
	if [ "$is_pop" = n ]
	then
		printf 'apply'
	else
		printf 'pop'
	fi
}

save_data() {
	target_data="$(if [ "$target_type" = 'orphan' ] ; then printf '~' ; fi ; printf '%s' "$target")"
	printf '%s\n' "$target_data" >"$target_data_file"
}
load_data() {
	if [ "$(wc -l <"$target_data_file")" -ne 1 ]
	then
		printf 'fatal: "%s" is should contain exactly 1 line.\n' "$target_data_file" 1>&2
		exit 1
	fi
	target="$(cat "$target_data_file")"
	if printf '%s' "$target" | grep -q '^~'
	then
		target="$(printf '%s' "$target" | cut -c2-)"
		target_type='orphan'
	else
		target_type='normal'
	fi
	if ! git rev-parse --quiet --verify "$target^{commit}" 1>/dev/null
	then
		printf 'fatal: "%s" says "%s" but there is no such commit.\n' "$target_data_file" "$target" 1>&2
		exit 1
	fi
	if [ "$target_type" != 'orphan' ] && [ "$(git rev-parse "$target")" = "$target" ]
	then
		target_type='detached'
	fi
}
delete_data() {
	rm -f "$target_data_file"
}

check_args_for_apply() { # max_free_args args...
	check_args 'istash-apply' "$@"
}

end_with_rebase_problem() {
	printf '\n' 1>&2
	if is_color_allowed 2
	then
		printf '\e[33m'
	fi
	sub_command_name="$(get_sub_command_name)"
	printf 'hint: Disregard all hints above about using "git rebase".\n' 1>&2
	printf 'hint: Use "git istash-%s --continue" after fixing conflicts.\n' "$sub_command_name" 1>&2
	printf 'hint: To abort and get back to the state before "git istash-%s", run "git istash-%s --abort".\n' "$sub_command_name" "$sub_command_name" 1>&2
	if is_color_allowed 2
	then
		printf '\e[39m'
	fi
	exit 1
}
end_with_success() {
	other_changes_hash="$(git rev-parse HEAD)"
	staged_changes_hash="$(git rev-parse HEAD~)"
	if [ "$target_type" != 'orphan' ] && [ "$(git rev-parse HEAD~2)" != "$(git rev-parse "$target")" ]
	then
		printf 'fatal: HEAD is not in correct position after rebasing.\n' 1>&2
		exit 1
	fi
	case "$target_type" in
		orphan)
			if [ "$(git rev-list --no-walk --count HEAD~2^@)" -ne 0 ]
			then
				printf 'fatal: Target branch is not an orphan anymore.\n' 1>&2
				exit 1
			fi
			if [ -n "$(git ls-tree -r --name-only HEAD~2)" ]
			then
				printf 'fatal: The empty commit created for the command is not empty.\n' 1>&2
				exit 1
			fi
			git branch --delete --force "$target"
			git switch --orphan "$target"
			;;
		normal)
			git switch "$target"
			;;
		detached)
			git switch -d HEAD~2
			;;
	esac
	git restore --source="$staged_changes_hash" -- . || true
	git add -- .
	git restore --source="$other_changes_hash" -- . || true
	delete_data
	printf '\nSuccessfully applied the stash\n'
}

check_data_files() { # resume
	if [ "$is_pop" = y ] ; then return 0 ; fi
	case "$(find_data_files)" in
		pop)
			printf '\n' 1>&2
			if is_color_allowed 2
			then
				printf '\e[33m'
			fi
			printf 'fatal: "git istash-pop" is already in progress?\n' 1>&2
			printf 'hint: Finish that operation before starting "git istash-apply".\n' 1>&2
			if is_color_allowed 2
			then
				printf '\e[39m'
			fi
			exit 1
			;;
		apply)
			if [ "$1" = y ] ; then return 0 ; fi
			if is_color_allowed 2
			then
				printf '\e[33m'
			fi
			printf 'fatal: "git istash-apply" is already in progress?\n' 1>&2
			printf 'hint: Use "git istash-apply --continue" or "git istash-apply --abort".\n' 1>&2
			if is_color_allowed 2
			then
				printf '\e[39m'
			fi
			exit 1
			;;
		error)
			printf '\n' 1>&2
			if is_color_allowed 2
			then
				printf '\e[31m'
			fi
			printf 'fatal: "git istash-pop" seems to be in progress but "%s" is missing!\n' "$target_data_file" 1>&2
			if is_color_allowed 2
			then
				printf '\e[33m'
			fi
			printf 'hint: Fix the problem and finish that operation before starting "git istash-apply"\n' 1>&2
			printf 'hint: or remove the file "%s" to manually cancel it.\n' "$(make_stash_data_file_path)" 1>&2
			if is_color_allowed 2
			then
				printf '\e[39m'
			fi
			exit 1
			;;
		nothing)
			if [ "$1" = n ] ; then return 0 ; fi
			printf 'fatal: No istash-apply in progress?\n' 1>&2
			exit 1
			;;
	esac
}

untangle_git_stash() {
	stash_commit="$(get_stash_commit "$stash")"
	git switch --detach "$stash_commit^2"
	git merge --ff-only --squash "$stash_commit"
	if git rev-parse "$stash_commit^3" 1>/dev/null 2>&1
	then
		git ls-tree -r --name-only "$stash_commit^3" -z \
		| xargs -r0 -- git restore --source="$stash_commit^3" --
		git add .
	fi
	git commit --no-edit --no-verify --allow-empty
}

do_start() { # args...
	check_args_for_apply 1 "$@"
	check_data_files n
	check_repository_state
	find_stash "$@"
	find_current_branch
	save_data
	
	if [ "$target_type" = 'orphan' ]
	then
		git commit --allow-empty --message 'Temporary commit by "git-stash"'
	fi
	untangle_git_stash
	if git rebase --onto "$target" "HEAD~2" "HEAD" --empty=keep --keep-empty
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_continue() { # args...
	check_args_for_apply 0 "$@"
	check_data_files y
	load_data
	
	if git -c 'core.editor=true' rebase --continue
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_abort() { # args...
	check_args_for_apply 0 "$@"
	check_data_files y
	load_data
	
	git rebase --abort || true  # Errors are ignored because if rebase is not in progress, we still want to try to restore HEAD.
	succeeded_switch=n
	case "$target_type" in
		orphan)
			git branch --delete --force "$target"
			if git switch --orphan "$target"
			then
				succeeded_switch=y
			fi
			;;
		normal)
			if git switch --quiet "$target"
			then
				succeeded_switch=y
			fi
			;;
		detached)
			if git switch --detach --quiet "$target"
			then
				succeeded_switch=y
			fi
			;;
	esac
	if [ "$succeeded_switch" = y ]
	then
		delete_data
		printf 'Aborted "git istash"\n' 1>&2
	else
		printf '\n' 1>&2
		printf 'fatal: Failed to restore HEAD.\n' 1>&2
		if is_color_allowed 2
		then
			printf '\e[33m'
		fi
		printf 'hint: Fix problems and rerun "git istash-%s --abort"\n' "$(get_sub_command_name)" 1>&2
		if [ "$is_pop" = n ]
		then
			printf 'hint: or delete the file "%s" to cancel manually.\n' "$target_data_file" 1>&2
		else
			printf 'hint: or delete the files "%s" and "%s" to cancel manually.\n' "$(make_stash_data_file_path)" "$target_data_file" 1>&2
		fi
		if is_color_allowed 2
		then
			printf '\e[39m'
		fi
		exit 1
	fi
}

do_unstash() { # args...
	if [ "$continue_set" = y ]
	then
		do_continue "$@"
	elif [ "$abort_set" = y ]
	then
		do_abort "$@"
	else
		do_start "$@"
	fi
}

getopt_result="$(getopt -o'hc' --long='help,continue,abort,called-from-pop' -n"$(basename "$0")" -- "$@")"
eval set -- "$getopt_result"
continue_set=n
abort_set=n
is_pop=n
while true
do
	case "$1" in
	-h|--help)
		print_help
		exit 0
		;;
	-c|--continue)
		continue_set=y
		;;
	--abort)
		abort_set=y
		;;
	--called-from-pop)
		is_pop=y
		;;
	--)
		shift
		break
		;;
	esac
	shift
done
if [ $continue_set = y ] && [ $abort_set = y ]
then
	printf 'error: Unclear whether to continue aborting or to abort continuing.\n' 1>&2
	exit 1
fi

cd "$(git rev-parse --show-toplevel)"
target_data_file="$(make_target_data_file_path)"
do_unstash "$@"
