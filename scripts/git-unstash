#!/usr/bin/env sh

set -e

show_help() {
	#shellcheck disable=SC2016
	printf 'git-unstash - Improved version of `git stash pop` the can handle conflicts.\n'
	printf '\n'
	printf 'usage: git unstash [<stash>]\n'
	printf '   or: git unstash (-c | --continue | --abort)\n'
}

find_data_file() {
	git_dir="$(git rev-parse --git-dir)"
	data_file="$git_dir/unstash"
}
save_data() {
	printf '%s\n%s\n%s\n' "$stash" "$current_branch" "$detached" >"$data_file"
}
load_data() {
	if ! [ -f "$data_file" ]
	then
		printf 'fatal: No unstash in progress?\n' 1>&2
		exit 1
	elif [ "$(wc -l "$data_file")" -ne 3 ]
	then
		printf 'fatal: "%s" is should contain 3 lines.\n' "$data_file" 1>&2
		exit 1
	else
		{
			read -r stash
			read -r current_branch
			read -r detached
		} <"$data_file"
		rm -f "$data_file"
	fi
}

check_args() { # max_free_args args...
	max_free_args="$1"
	shift
	if [ $# -gt "$max_free_args" ]
	then
		printf 'error: Too many arguments.\n' 1>&2
		#shellcheck disable=SC2016
		printf 'error: Type `git unstash --help` for more information.\n' 1>&2
		exit 1
	fi
}

end_with_rebase_problem() {
	#shellcheck disable=SC2016
	printf '\nwarning: Do NOT use `git rebase --continue`! Instead use `git unstash --continue`.\n' 1>&2
	save_data
}
end_with_success() {
	git reset --mixed HEAD~
	git reset --soft HEAD~
	if [ "$detached" -eq 0 ]
	then
		git switch "$current_branch"
	fi
	git stash drop "$stash"
}

check_repository_state() {
	if ! git diff --quiet HEAD
	then
		# There are still are some limitations.
		printf 'error: There are uncommitted changes in the working directory.\n' 1>&2
		printf 'error: Please commit or stash them.\n' 1>&2
		exit 1
	fi
}

find_stash() { # [arg]
	if [ $# -eq 0 ]
	then
		stash='stash@{0}'
	elif [ "$1" -eq "$1" ] 2>/dev/null
	then
		stash="stash@{$1}"
	else
		stash="$1"
	fi
	
	if ! git rev-parse --quiet --verify "$stash^{commit}" 1>/dev/null
	then
		printf 'fatal: There is no commit "%s".\n' "$stash" 1>&2
		exit 1
	fi
	parents_num="$(git rev-list --no-walk --count "$stash^@")"
	if [ "$parents_num" -lt 2 ] || [ "$parents_num" -gt 3 ]
	then
		printf 'fatal: "%s" should have 2 or 3 parents.\n' "$stash" 1>&2
		exit 1
	fi
	if [ "$parents_num" -eq 3 ] && [ "$(git rev-list --no-walk --count "$stash^3^@")" -ne 0 ]
	then
		printf 'fatal: "%s^3" should have no parents.\n' "$stash" 1>&2
		exit 1
	fi
	if [ "$(git rev-list --no-walk --count "$stash^2^@")" -ne 1 ]
	then
		printf 'fatal: The commit "%s^2" should have one parent.\n' "$stash" 1>&2
		exit 1
	fi
	if [ "$(git rev-parse "$stash^1")" != "$(git rev-parse "$stash^2^")" ]
	then
		printf 'fatal: The commit "%s^1" should be the parent of "%s^2".\n' "$stash" "$stash" 1>&2
		exit 1
	fi
	correct_commit_msgs=0
	if [ "$parents_num" -eq 3 ] && git rev-list --format='%B' --max-count=1 "$stash^3" | head -n 2 | tail -n 1 | grep -q '^untracked files on .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if git rev-list --format='%B' --max-count=1 "$stash^2" | head -n 2 | tail -n 1 | grep -q '^index on .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if git rev-list --format='%B' --max-count=1 "$stash" | head -n 2 | tail -n 1 | grep -q '^\(WIP on\|On\) .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if [ $correct_commit_msgs -ne "$parents_num" ]
	then
		if [ $correct_commit_msgs -eq 0 ]
		then
			printf 'error: "%s"'\''s commits don'\''t have correct messages for stash.\n' "$stash" 1>&2
		else
			printf 'error: some of "%s"'\'' commits don'\''t have correct messages for stash.\n' "$stash" 1>&2
		fi
		printf 'error: It may not be a stash entry or it may be damaged.\n'
		exit 1
	fi
}

find_current_branch() {
	detached=0
	current_branch="$(git rev-parse --abbrev-ref HEAD)"
	if [ "$current_branch" = 'HEAD' ]
	then
		detached=1
		current_branch="$(git rev-parse HEAD)"
	fi
}

check_sanity() {
	if [ "$(git rev-parse "$current_branch")" = "$(git rev-parse "$stash")" ] || [ "$(git rev-parse "$current_branch")" = "$(git rev-parse "$stash^2")" ] || [ "$(git rev-parse "$current_branch")" = "$(git rev-parse "$stash^3" 2>/dev/null)" ]
	then
		printf 'error: HEAD is part of the stash.\n' 1>&2
		printf 'error: This is insane; I refuse.\n' 1>&2
		exit 1
	fi
}

untangle_git_stash() {
	git switch --detach "$stash^2"
	git merge --ff-only --squash "$stash"
	if git rev-parse "$stash^3" 1>/dev/null 2>&1
	then
		git ls-tree -r --name-only "$stash^3" -z \
		| xargs -r0 -- git restore --source="$stash^3" --
		git add .
	fi
	git commit --no-edit --no-verify --allow-empty
}

do_start() { # args...
	check_args 1 "$@"
	check_repository_state
	find_stash "$@"
	find_current_branch
	check_sanity
	
	untangle_git_stash
	if git rebase --onto "$current_branch" "HEAD~2" "HEAD"
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_continue() { # args...
	check_args 0 "$@"
	load_data
	
	if git -c 'core.editor=true' rebase --continue
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_abort() { # args...
	check_args 0 "$@"
	load_data
	
	git rebase --abort
	git switch --quiet "$current_branch"
}

do_unstash() { # args...
	if [ "$1" = '--continue' ] || [ "$1" = '-c' ]
	then
		shift
		do_continue "$@"
	elif [ "$1" = '--abort' ]
	then
		shift
		do_abort "$@"
	else
		do_start "$@"
	fi
}

getopt_result="$(getopt -o h --long help -n "$(basename "$0")" -- "$@")"
eval set -- "$getopt_result"
while true
do
	case "$1" in
	-h|--help)
		show_help
		exit 0
		;;
	--)
		shift
		break
		;;
	esac
done

find_data_file
do_unstash "$@"
