#!/usr/bin/env sh

set -e

is_color_allowed() { # stream_num
	case "$(git config --get color.ui)" in
		always|true|1) return 0 ;;
		never|false|0) return 1 ;;
		*)             test -t "$1" ;;
	esac
}

print_help() {
	printf 'git-unstash - Improved version of "git stash pop" the can handle conflicts.\n'
	printf '\n'
	printf 'usage: git unstash [<stash>]\n'
	printf '   or: git unstash (-c | --continue | --abort)\n'
}

find_data_file() {
	git_dir="$(git rev-parse --git-dir)"
	data_file="$git_dir/unstash"
}
save_data() {
	printf '%s\n%s\n%s\n' "$stash" "$current_branch" "$detached" >"$data_file"
}
does_data_exits() {
	test -f "$data_file"
}
load_data() {
	if ! does_data_exits
	then
		printf 'fatal: No unstash in progress?\n' 1>&2
		exit 1
	elif [ "$(wc -l <"$data_file")" -ne 3 ]
	then
		printf 'fatal: "%s" is should contain 3 lines.\n' "$data_file" 1>&2
		exit 1
	else
		{
			read -r stash
			read -r current_branch
			read -r detached
		} <"$data_file"
	fi
}
delete_data() {
	rm -f "$data_file"
}

check_args() { # max_free_args args...
	max_free_args="$1"
	shift
	if [ $# -gt "$max_free_args" ]
	then
		printf 'error: Too many arguments.\n' 1>&2
		printf 'error: Type "git unstash --help" for more information.\n' 1>&2
		exit 1
	fi
}

end_with_rebase_problem() {
	printf '\n' 1>&2
	if is_color_allowed 2
	then
		printf '\e[33m'
	fi
	printf 'hint: Disregard all hints above about using "git rebase".\n' 1>&2
	printf 'hint: Use "git unstash --continue" after fixing conflicts.\n' 1>&2
	printf 'hint: To abort and get back to the state before "git unstash", run "git unstash --abort".\n' 1>&2
	if is_color_allowed 2
	then
		printf '\e[39m'
	fi
	exit 1
}
end_with_success() {
	other_changes_hash="$(git rev-parse HEAD)"
	staged_changes_hash="$(git rev-parse HEAD~)"
	if printf '%s' "$current_branch" | grep -q '^~'
	then
		current_branch="$(printf '%s' "$current_branch" | cut -c2-)"
		git branch --delete --force "$current_branch"
		git switch --orphan="$current_branch"
	elif [ "$detached" = n ]
	then
		git switch "$current_branch"
	else
		git switch -d HEAD~2
	fi
	git restore --source="$staged_changes_hash" -- . || true
	git add -- .
	git restore --source="$other_changes_hash" -- . || true
	delete_data
	if printf '%s' "$stash" | grep -xq 'stash@{[0-9]\+}'
	then
		git stash drop "$stash"
	fi
	printf '\nSuccessfully unstashed the stash\n' 1>&2
}

check_repository_state() {
	if [ -n "$(git status --porcelain)" ]
	then
		# There are still are some limitations.
		printf 'error: There are uncommitted changes in the working directory.\n' 1>&2
		printf 'error: Please commit or stash them.\n' 1>&2
		exit 1
	fi
}

find_stash() { # [arg]
	if [ $# -eq 0 ] || [ "$1" = 'stash' ]
	then
		stash='stash@{0}'
	elif [ "$1" -eq "$1" ] 2>/dev/null
	then
		if [ "$1" -ge 0 ]
		then
			stash="stash@{$1}"
		else
			stash="stash@{$(($(git rev-list --walk-reflogs --count --ignore-missing refs/stash) + $1))}"
		fi
	elif printf '%s' "$1" | grep -xq 'stash\^{/.*}'
	then
		stash_text="$(printf '%s' "$1" | sed 's/^stash\^{\/\(.*\)}$/\1/')"
		stash_hash="$(git rev-list --walk-reflogs --grep-reflog="$stash_text" --ignore-missing refs/stash | head -n1)"
		stash="stash@{$(($(git rev-list --walk-reflogs refs/stash | grep -Fxn "$stash_hash" | cut -d: -f1) - 1))}"
	else
		stash="$1"
	fi
	
	if ! git rev-parse --quiet --verify "$stash^{commit}" 1>/dev/null
	then
		printf 'fatal: There is no commit "%s".\n' "$stash" 1>&2
		exit 1
	fi
	parents_num="$(git rev-list --no-walk --count "$stash^@")"
	if [ "$parents_num" -lt 2 ] || [ "$parents_num" -gt 3 ]
	then
		printf 'fatal: "%s" should have 2 or 3 parents to be a stash.\n' "$stash" 1>&2
		exit 1
	fi
	if [ "$parents_num" -eq 3 ] && [ "$(git rev-list --no-walk --count "$stash^3^@")" -ne 0 ]
	then
		printf 'fatal: "%s^3" should have no parents to be a part of a stash.\n' "$stash" 1>&2
		exit 1
	fi
	if [ "$(git rev-list --no-walk --count "$stash^2^@")" -ne 1 ]
	then
		printf 'fatal: The commit "%s^2" should have one parent to be a part of a stash.\n' "$stash" 1>&2
		exit 1
	fi
	if [ "$(git rev-parse "$stash^1")" != "$(git rev-parse "$stash^2^")" ]
	then
		printf 'fatal: The commit "%s^1" should be the parent of "%s^2" to be a part of a stash.\n' "$stash" "$stash" 1>&2
		exit 1
	fi
	correct_commit_msgs=0
	if [ "$parents_num" -eq 3 ] && git rev-list --format='%B' --max-count=1 "$stash^3" | head -n 2 | tail -n 1 | grep -q '^untracked files on .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if git rev-list --format='%B' --max-count=1 "$stash^2" | head -n 2 | tail -n 1 | grep -q '^index on .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if git rev-list --format='%B' --max-count=1 "$stash" | head -n 2 | tail -n 1 | grep -q '^\(WIP on\|On\) .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if [ $correct_commit_msgs -ne "$parents_num" ]
	then
		if [ $correct_commit_msgs -eq 0 ]
		then
			printf 'error: "%s"'\''s commits don'\''t have correct messages for stash.\n' "$stash" 1>&2
		else
			printf 'error: some of "%s"'\'' commits don'\''t have correct messages for stash.\n' "$stash" 1>&2
		fi
		printf 'error: It may not be a stash entry or it may be damaged.\n'
		exit 1
	fi
}

find_current_branch() {
	detached=n
	if git rev-parse HEAD >/dev/null 2>&1
	then
		current_branch="$(git rev-parse --abbrev-ref HEAD)"
		if [ "$current_branch" = 'HEAD' ]
		then
			detached=y
			current_branch="$(git rev-parse HEAD)"
		fi
	else
		current_branch="~$(git branch --show-current)"
	fi
}

untangle_git_stash() {
	git switch --detach "$stash^2"
	git merge --ff-only --squash "$stash"
	if git rev-parse "$stash^3" 1>/dev/null 2>&1
	then
		git ls-tree -r --name-only "$stash^3" -z \
		| xargs -r0 -- git restore --source="$stash^3" --
		git add .
	fi
	git commit --no-edit --no-verify --allow-empty
}

do_start() { # args...
	check_args 1 "$@"
	if does_data_exits
	then
		printf '\n' 1>&2
		if is_color_allowed 2
		then
			printf '\e[33m'
		fi
		printf 'fatal: Unstash already in progress?\n' 1>&2
		printf 'hint: Use "git unstash --continue" or "git unstash --abort".\n' 1>&2
		if is_color_allowed 2
		then
			printf '\e[39m'
		fi
		exit 1
	fi
	check_repository_state
	find_stash "$@"
	find_current_branch
	save_data
	
	if printf '%s' "$current_branch" | grep -q '^~'
	then
		git commit --allow-empty --message 'Temporary commit by "git-stash"'
		rebase_branch="$(printf '%s' "$current_branch" | cut -c2-)"
	else
		rebase_branch="$current_branch"
	fi
	untangle_git_stash
	if git rebase --onto "$rebase_branch" "HEAD~2" "HEAD" --empty=keep --keep-empty
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_continue() { # args...
	check_args 0 "$@"
	load_data
	
	if git -c 'core.editor=true' rebase --continue
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_abort() { # args...
	check_args 0 "$@"
	load_data
	
	git rebase --abort || true  # Errors are ignored because if rebase is not in progress, we still want to try to restore HEAD.
	succeeded_switch=n
	if printf '%s' "$current_branch" | grep -q '^~'
	then
		current_branch="$(printf '%s' "$current_branch" | cut -c2-)"
		git branch --delete --force "$current_branch"
		if git switch --orphan="$current_branch"
		then
			succeeded_switch=y
		fi
	elif [ "$detached" = n ]
	then
		if git switch --quiet "$current_branch"
		then
			succeeded_switch=y
		fi
	else
		if git switch --detach --quiet "$current_branch"
		then
			succeeded_switch=y
		fi
	fi
	if [ "$succeeded_switch" = y ]
	then
		delete_data
		printf 'Aborted "git unstash"\n' 1>&2
	else
		printf '\n' 1>&2
		printf 'fatal: Failed to restore HEAD.\n' 1>&2
		if is_color_allowed 2
		then
			printf '\e[33m'
		fi
		printf 'hint: Fix problems and rerun "git unstash --abort"\n' 1>&2
		printf 'hint: or delete file "%s" to cancel manually.\n' "$data_file" 1>&2
		if is_color_allowed 2
		then
			printf '\e[39m'
		fi
		exit 1
	fi
}

do_unstash() { # args...
	if [ "$continue_set" = y ]
	then
		do_continue "$@"
	elif [ "$abort_set" = y ]
	then
		do_abort "$@"
	else
		do_start "$@"
	fi
}

getopt_result="$(getopt -o'hc' --long='help,continue,abort' -n"$(basename "$0")" -- "$@")"
eval set -- "$getopt_result"
continue_set=n
abort_set=n
while true
do
	case "$1" in
	-h|--help)
		print_help
		exit 0
		;;
	-c|--continue)
		continue_set=y
		;;
	--abort)
		abort_set=y
		;;
	--)
		shift
		break
		;;
	esac
	shift
done
if [ $continue_set = y ] && [ $abort_set = y ]
then
	printf 'error: Unclear whether to continue aborting or to abort continuing.\n' 1>&2
	exit 1
fi

cd "$(git rev-parse --show-toplevel)"
find_data_file
do_unstash "$@"
