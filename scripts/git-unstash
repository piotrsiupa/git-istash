#!/usr/bin/env sh

set -e

show_help() {
	#shellcheck disable=SC2016
	printf 'This command is similar to `git stash pop --index` but it can handle conflicts.\n'
	printf '\n'
	printf 'Usage:\t%s [ENTRY]\n' "$0"
	printf '\t%s --continue\n' "$0"
}

yes_no() { # question
	printf '%s [yes/no]\n' "$1" 1>&2
	while read -r answer
	do
		if printf '%s' "$answer" | grep -iq '^y\(es\)\?$'
		then
			return 0
		elif printf '%s' "$answer" | grep -iq '^no\?$'
		then
			return 1
		else
			printf 'Answer "yes" or "no".\n' 1>&2
		fi
	done
	return 2
}

find_data_file() {
	git_dir="$(git rev-parse --git-dir)"
	data_file="$git_dir/unstash"
}
save_data() {
	printf '%s\n%s\n%s\n' "$stash" "$current_branch" "$detached" >"$data_file"
}
load_data() {
	if ! [ -f "$data_file" ]
	then
		printf 'There is no "unstash" operation in progress!\n' 1>&2
		exit 1
	elif [ "$(wc -l "$data_file")" -ne 3 ]
	then
		printf 'The file "%s" is broken! (It should have 3 lines.)\n' "$data_file" 1>&2
		exit 1
	else
		{
			read -r stash
			read -r current_branch
			read -r detached
		} <"$data_file"
		rm -f "$data_file"
	fi
}

check_args() { # max_free_args args...
	max_free_args="$1"
	shift
	if [ $# -gt "$max_free_args" ]
	then
		printf 'Too many arguments!\n' 1>&2
		exit 1
	fi
}

end_with_rebase_problem() {
	#shellcheck disable=SC2016
	printf 'USE `%s --continue` INSTEAD OF `git rebase --continue`!\n' "$0"
	save_data
}
end_with_success() {
	git reset --mixed HEAD~
	git reset --soft HEAD~
	if [ "$detached" -eq 0 ]
	then
		git switch "$current_branch"
	fi
	git stash drop "$stash"
}

check_repository_state() {
	if ! git diff --quiet HEAD
	then
		# There are still are some limitations.
		printf 'There are uncommitted changes in the working directory!\n' 1>&2
		printf 'Commit or stash them before attempting unstashing with index.\n' 1>&2
		exit 1
	fi
}

find_stash() { # [arg]
	if [ $# -eq 0 ]
	then
		stash='stash@{0}'
	elif [ "$1" -eq "$1" ] 2>/dev/null
	then
		stash="stash@{$1}"
	else
		stash="$1"
	fi
	
	if ! git rev-parse --quiet --verify "$stash^{commit}" 1>/dev/null
	then
		printf 'There is no commit "%s"!\n' "$stash" 1>&2
		exit 1
	fi
	parents_num="$(git rev-list --no-walk --count "$stash^@")"
	if [ "$parents_num" -lt 2 ] || [ "$parents_num" -gt 3 ]
	then
		printf 'The commit "%s" should have 2 or 3 parents! (it has %i)\n' "$stash" "$parents_num" 1>&2
		exit 1
	fi
	if [ "$parents_num" -eq 3 ] && [ "$(git rev-list --no-walk --count "$stash^3^@")" -ne 0 ]
	then
		printf 'The commit "%s^3" should have no parents!\n' "$stash" 1>&2
		exit 1
	fi
	if [ "$(git rev-list --no-walk --count "$stash^2^@")" -ne 1 ]
	then
		printf 'The commit "%s^2" should have one parent!\n' "$stash" 1>&2
		exit 1
	fi
	if [ "$(git rev-parse "$stash^1")" != "$(git rev-parse "$stash^2^")" ]
	then
		printf 'The commit "%s^1" should be the parent of "%s^2"!\n' "$stash" "$stash" 1>&2
		exit 1
	fi
	correct_commit_msgs=0
	if [ "$parents_num" -eq 3 ] && git rev-list --format='%B' --max-count=1 "$stash^3" | head -n 2 | tail -n 1 | grep -q '^untracked files on .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if git rev-list --format='%B' --max-count=1 "$stash^2" | head -n 2 | tail -n 1 | grep -q '^index on .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if git rev-list --format='%B' --max-count=1 "$stash" | head -n 2 | tail -n 1 | grep -q '^\(WIP on\|On\) .\+:'
	then
		correct_commit_msgs=$((correct_commit_msgs + 1))
	fi
	if [ $correct_commit_msgs -ne "$parents_num" ]
	then
		if [ $correct_commit_msgs -eq 0 ]
		then
			printf 'Commits from the tree of "%s" don'\''t have correct messages for stash!\n' "$stash" 1>&2
		else
			printf 'Some of the commits from the tree of "%s" don'\''t have correct messages for stash!\n' "$stash" 1>&2
		fi
		printf 'It may not be a stash entry or it may be damaged.\n'
		if ! yes_no 'Do you want to continue?'
		then
			exit 2
		fi
	fi
}

find_current_branch() {
	detached=0
	current_branch="$(git rev-parse --abbrev-ref HEAD)"
	if [ "$current_branch" = 'HEAD' ]
	then
		detached=1
		current_branch="$(git rev-parse HEAD)"
	fi
}

check_sanity() {
	if [ "$(git rev-parse "$current_branch")" = "$(git rev-parse "$stash")" ] || [ "$(git rev-parse "$current_branch")" = "$(git rev-parse "$stash^2")" ] || [ "$(git rev-parse "$current_branch")" = "$(git rev-parse "$stash^3" 2>/dev/null)" ]
	then
		printf 'The current "HEAD" is part of the stash entry!\n' 1>&2
		printf 'This is insane; I refuse.\n' 1>&2
		exit 1
	fi
}

untangle_git_stash() {
	git switch --detach "$stash^2"
	git merge --ff-only --squash "$stash"
	if git rev-parse "$stash^3" 1>/dev/null 2>&1
	then
		git ls-tree -r --name-only "$stash^3" -z \
		| xargs -r0 -- git restore --source="$stash^3" --
		git add .
	fi
	git commit --no-edit --no-verify --allow-empty
}

do_start() { # args...
	check_args 1 "$@"
	check_repository_state
	find_stash "$@"
	find_current_branch
	check_sanity
	
	untangle_git_stash
	if git rebase --onto "$current_branch" "HEAD~2" "HEAD"
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_continue() { # args...
	check_args 0 "$@"
	load_data
	
	if git -c 'core.editor=true' rebase --continue
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_abort() { # args...
	check_args 0 "$@"
	load_data
	
	git rebase --abort
	git switch --quiet "$current_branch"
}

do_unstash() { # args...
	if [ "$1" = '--continue' ] || [ "$1" = '-c' ]
	then
		shift
		do_continue "$@"
	elif [ "$1" = '--abort' ]
	then
		shift
		do_abort "$@"
	else
		do_start "$@"
	fi
}

getopt_result="$(getopt -o h --long help -n "$(basename "$0")" -- "$@")"
eval set -- "$getopt_result"
while true
do
	case "$1" in
	-h|--help)
		show_help
		exit 0
		;;
	--)
		shift
		break
		;;
	esac
done

find_data_file
do_unstash "$@"
