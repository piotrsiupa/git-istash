#!/usr/bin/env sh

set -e

show_help() {
	printf 'This command is similar to `git stash pop --index` but it can handle conflicts.\n'
	printf '\n'
	printf 'Usage:\t%s [ENTRY]\n' "$0"
	printf '\t%s --continue\n' "$0"
}

find_data_file() {
	git_dir="$(git rev-parse --git-dir)"
	data_file="$git_dir/unstash"
}
save_data() {
	printf '%s\n%s\n%s\n' "$stash" "$current_branch" "$detached" >"$data_file"
}
load_data() {
	if ! [ -f "$data_file" ]
	then
		printf 'There is no "unstash" operation in progress!\n' 1>&2
		exit 1
	elif [ "$(wc -l "$data_file")" -ne 3 ]
	then
		printf 'The file "%s" is broken! (It should have 3 lines.)\n' "$data_file" 1>&2
		exit 1
	else
		{
			read -r stash
			read -r current_branch
			read -r detached
		} <"$data_file"
		rm -f "$data_file"
	fi
}

check_args() { # max_free_args args...
	max_free_args="$1"
	shift
	if [ "$1" != "${1#-}" ]
	then
		printf 'Unknown option "%s"!\n' "$1" 1>&2
		exit 1
	elif [ $# -gt "$max_free_args" ]
	then
		printf 'Too many arguments!\n' 1>&2
		exit 1
	fi
}

end_with_rebase_problem() {
	printf 'USE `%s --continue` INSTEAD OF `git rebase --continue`!\n' "$0"
	save_data
}
end_with_success() {
	git reset --mixed HEAD~
	git reset --soft HEAD~
	if [ "$detached" -eq 0 ]
	then
		git switch "$current_branch"
	fi
	git stash drop "$stash"
}

check_repository_state() {
	if ! git diff --quiet HEAD
	then
		# There are still are some limitations.
		printf 'There are uncommitted changes in the working directory!\n' 1>&2
		printf 'Commit or stash them before attempting unstashing with index.\n' 1>&2
		exit 1
	fi
}

find_stash() { # [arg]
	if [ $# -eq 0 ]
	then
		stash='stash@{0}'
	elif [ "$1" -eq "$1" ] 2>/dev/null
	then
		stash="stash@{$1}"
	else
		stash="$1"
	fi
}

find_current_branch() {
	detached=0
	current_branch="$(git rev-parse --abbrev-ref HEAD)"
	if [ "$current_branch" = 'HEAD' ]
	then
		detached=1
		current_branch="$(git rev-parse HEAD)"
	fi
}

untangle_git_stash() {
	git switch --detach "$stash^2"
	git merge --ff-only --squash "$stash"
	if git rev-parse "$stash^3" 1>/dev/null 2>&1
	then
		git ls-tree -r --name-only "$stash^3" -z \
		| xargs -0 -- git restore --source="$stash^3" --
		git add .
	fi
	git commit --no-edit --no-verify --allow-empty
}

do_start() { # args...
	check_args 1 "$@"
	check_repository_state
	find_stash "$@"
	find_current_branch
	
	untangle_git_stash
	if git rebase --onto "$current_branch" "HEAD~2" "HEAD"
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_continue() { # args...
	check_args 0 "$@"
	load_data
	
	if git -c 'core.editor=true' rebase --continue
	then
		end_with_success
	else
		end_with_rebase_problem
	fi
}

do_abort() { # args...
	check_args 0 "$@"
	load_data
	
	git rebase --abort
	git switch --quiet "$current_branch"
}

do_unstash() { # args...
	if [ "$1" = '--continue' ] || [ "$1" = '-c' ]
	then
		shift
		do_continue "$@"
	elif [ "$1" = '--abort' ]
	then
		shift
		do_abort "$@"
	else
		do_start "$@"
	fi
}

if [ "$1" = '--help' ] || [ "$1" = '-h' ]
then
	show_help
else
	find_data_file
	do_unstash "$@"
fi
